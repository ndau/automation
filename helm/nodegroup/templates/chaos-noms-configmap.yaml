{{ if .Values.chaos.enabled }}

kind: ConfigMap
metadata:
  name: {{ template "nodegroup.fullname" . }}-chaos-noms-config
  labels:
    app: {{ template "nodegroup.name" . }}
    chart: {{ template "nodegroup.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
apiVersion: v1
data:
  make-snapshot.sh: |

    # import lib scripts
    for f in /root/lib/*.sh; do source $f; done

    log () {
      >&2 echo "chaos-noms-make-snapshot: $@"
    }

    err () {
      >&2 echo "chaos-noms-make-snapshot: $@"
      exit 1
    }

    this_node=chaos
    this_app=noms

    # begin making snapshot

    # wait for redis
    log "Pinging redis."
    while true ; do
      # get redis readiness
      if ! redis_cli PING; then
        log "Waiting for redis to pong."
        sleep 1
      else
        log "Redis is ready."
        break
      fi
    done

    # wait for height value
    height="$(get_height $CHAIN)"

    # upload the database

    # check to see if the snapshot is already there
    tar_file=$THIS_SERVICE.tgz
    s3_path="/{{ .Values.aws.snapshotBucket }}/{{ .Values.networkName }}/${this_node}-${height}/${tar_file}"

    if curl_response=$(curl -I -f "http://s3.amazonaws.com$s3_path"); then
      log "Snapshot $s3_path already exists. Will not upload."
    else
      log "Uploading snapshot $s3_path."

      (
        cd /noms/data
        tar cvzf /root/$tar_file *
      )

      s3_upload /root/$tar_file $tar_file

    fi

    # delete service flag
    redis_cli DEL "snapshot-$THIS_SERVICE"

  shutdown-waits.sh: |

    # import lib scripts
    for f in /root/lib/*.sh; do source $f; done

    log () {
      >&2 echo "$THIS_SERVICE-shutdown: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-shutdown: $@"
      exit 1
    }

    log "Starting wait loops"
    wait_until_down chaosnode
    log "Done"

{{ end }}
