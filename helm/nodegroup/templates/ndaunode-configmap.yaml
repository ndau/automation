{{ if .Values.ndau.enabled }}

kind: ConfigMap
metadata:
  name: {{ template "nodegroup.fullname" . }}-ndaunode-config
  labels:
    app: {{ template "nodegroup.name" . }}
    chart: {{ template "nodegroup.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
apiVersion: v1
data:
  config.toml: |
    ChaosAddress = "CHAOS_ADDRESS_TOKEN"
    UseMock = "" # This needs to be empty

    ChaosTimeout = 500 # seconds

    [SystemVariableIndirect]
      Key = "c3Zp"
      Namespace = "NAMESPACE_TOKEN"

  init.sh: |

    CURL_RETRIES=10
    CURL_RETRY_DELAY=0
    CFG_DIR=$NDAUHOME/ndau
    NDAU_CONFIG_TOML="$CFG_DIR"/config.toml
    NAMESPACE_FILE="$CFG_DIR"/svi-namespace
    NAMESPACE_URL=https://s3.amazonaws.com/{{ .Values.aws.snapshotBucket }}/{{ .Values.networkName }}/svi-namespace

    # Copy readonly config files to real config files
    if [ ! -d "$CFG_DIR" ]; then
      echo "Creating ndau config directory. $CFG_DIR"
      mkdir -p "$CFG_DIR"
    else
      echo "Not creating ndau config directory. $CFG_DIR"
    fi

    if [ ! -f "$NDAU_CONFIG_TOML" ]; then

      echo "copying config.toml"
      cp /root/config-ro/config.toml "$NDAU_CONFIG_TOML"

      echo "getting new svi-namespace"
      NAMESPACE_URL=https://s3.amazonaws.com/{{ .Values.aws.snapshotBucket }}/{{ .Values.networkName }}/svi-namespace
      if curl "$NAMESPACE_URL" -o "$NAMESPACE_FILE" --retry $CURL_RETRIES --retry-delay 0; then
        SVI_NAMESPACE=$(cat "$NAMESPACE_FILE")
        echo "Fetched namsepace: $SVI_NAMESPACE"
      else
        echo "could not get namespace from $NAMESPACE_URL"
        if [ -f "$NAMESPACE_FILE" ]; then
          SVI_NAMESPACE=$(cat "$NAMESPACE_FILE")
          echo "Using previously fetched namsepace: $SVI_NAMESPACE"
        else
          echo "No previously fetched namsepace at: "$NAMESPACE_FILE""
          exit 1
        fi
      fi

      echo "replacing namespace token in $NDAU_CONFIG_TOML"
      sed -i "s~NAMESPACE_TOKEN~$SVI_NAMESPACE~" "$NDAU_CONFIG_TOML"

      echo "replacing chaos address"

      fullname="{{ template "nodegroup.fullname" . }}"
      RELEASE=$(echo ${fullname//-/_} | awk '{print toupper($0)}')
      HOST_VAR=${RELEASE}_CHAOS_TENDERMINT_SERVICE_SERVICE_HOST
      RPC_PORT_VAR=${RELEASE}_CHAOS_TENDERMINT_SERVICE_SERVICE_PORT_RPC

      # variable indirection
      host=${!HOST_VAR}
      rpc_port=${!RPC_PORT_VAR}

      chaos_address=http://${host}:${rpc_port}

      sed -i "s~CHAOS_ADDRESS_TOKEN~$chaos_address~" "$NDAU_CONFIG_TOML"

      echo "$NDAU_CONFIG_TOML is now:"
      cat "$NDAU_CONFIG_TOML"
    else
      echo "config.toml already exists. Will not update."
    fi

    # Show what files are there
    find /root/.ndau

  ndaunode-start.sh: |
    log () {
      >&2 echo "$THIS_SERVICE-start: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-start: $@"
      exit 1
    }

    startup() {
      log "Starting"

      if [ "$SNAPSHOTGUN_ENABLED" == "true" ]; then
        # if snapshot is taking place, wait until done
        tries_left=30 # approx 1 minute
        log "waiting for snapshot to finish"
        # wait until done snapping, or, timed out
        until [ "$resp" == "-1" ]; do
          [[ "$tries_left" -lt "1" ]] && break
          resp=$(timeout -t 1 /bin/bash /root/redis-cli.sh -h $R_HOST get "snapshot-snapping")
          sleep 1
          tries_left=$((tries_left-1))
          log "Waiting $tries_left more times."
        done
      fi

      >&2 /bin/bash /root/startup-waits.sh

      ndaunode \
        -spec http://{{ template "nodegroup.fullname" . }}-ndau-noms-service:{{ .Values.ndau.noms.port }} \
        -addr 0.0.0.0:{{ required ".Values.ndaunode.port required" .Values.ndaunode.port }} \
        -index {{ template "nodegroup.fullname" . }}-ndau-redis-service:{{ .Values.ndau.redis.port }} &

      pid=$! # get ndaunode pid
    }

    snapshot() {
      log "starting snapshot"
      kill $pid
      while kill -0 $pid; do log "waiting for $THIS_SERVICE to stop"; sleep 1; done;
      log "done waiting"
      /bin/bash -x /root/make-snapshot.sh >&1
      startup
    }

    shutdown() {
      log "Shutting down"
      >&2 /bin/bash /root/shutdown-waits.sh
      kill $pid
      while kill -0 $pid; do log "waiting for $THIS_SERVICE to stop"; sleep 1; done;
      log "done waiting"
      exit 0
    }

    startup

    # wait for a sigterm and run shutdown
    trap shutdown SIGTERM

    # main loop
    log "starting main loop"
    while true; do
      if [ "$SNAPSHOTGUN_ENABLED" == "true" ]; then
        # snapshot if this service has been told to snapshot by redis
        sleep 2
        res=$(timeout -t 2 /bin/bash /root/redis-cli.sh -h $R_HOST get "snapshot-$THIS_SERVICE")
        [ "$res" == "1" ] && snapshot
      else
        sleep 42
      fi
    done



  startup-waits.sh: |
    #!/bin/bash

    log () {
      >&2 echo "$THIS_SERVICE-startup-waits: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-startup-waits: $@"
      exit 1
    }

    wait_for() {
      service=$1
      pod=$2
      port=$3

      log starting $service wait loop
      until nc -z -w 1 $pod $port; do
        log waiting for $pod on $port to accept connection
        sleep 2
      done
    }

    log "Starting wait loops"
    wait_for redis {{ template "nodegroup.fullname" . }}-ndau-redis-service {{ .Values.ndau.redis.port }}
    wait_for noms {{ template "nodegroup.fullname" . }}-ndau-noms-service {{ .Values.ndau.noms.port }}
    log "Done"

    # get chaosnode's address from env vars
    fullname="{{ template "nodegroup.fullname" . }}"
    RELEASE=$(echo ${fullname//-/_} | awk '{print toupper($0)}')
    HOST_VAR=${RELEASE}_CHAOS_TENDERMINT_SERVICE_SERVICE_HOST
    RPC_PORT_VAR=${RELEASE}_CHAOS_TENDERMINT_SERVICE_SERVICE_PORT_RPC
    host=${!HOST_VAR}
    rpc_port=${!RPC_PORT_VAR}

    wait_for chaosnode $host $rpc_port



  shutdown-waits.sh: |

    log () {
      >&2 echo "$THIS_SERVICE-shutdown-waits: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-shutdown-waits: $@"
      exit 1
    }

    # wait for waits until a service is shut down
    wait_for() {
      service=$1
      pod=$2
      port=$3

      log starting $service wait loop
      while nc -z -w 1 $pod $port; do
        log waiting for $pod on $port to become inactive
        sleep 2
      done
    }

    log "Starting wait loops"
    wait_for ndau-tm {{ template "nodegroup.fullname" . }}-ndau-tendermint-service {{ .Values.ndau.tendermint.ports.rpc }}
    log "Done"


{{ end }}
