{{ if .Values.chaos.enabled }}

kind: ConfigMap
metadata:
  name: {{ template "nodegroup.fullname" . }}-chaosnode-config
  labels:
    app: {{ template "nodegroup.name" . }}
    chart: {{ template "nodegroup.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
apiVersion: v1
data:
  chaosnode-start.sh: |
    log () {
      >&2 echo "$THIS_SERVICE-start: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-start: $@"
      exit 1
    }

    startup() {
      log "Starting"

      if [ "$SNAPSHOTGUN_ENABLED" == "true" ]; then
        # if snapshot is taking place, wait until done
        tries_left=30 # approx 1 minute
        log "waiting for snapshot to finish"
        # wait until done snapping, or, timed out
        while [ "$resp" != "-1" ]; do
          [[ "$tries_left" -lt "1" ]] && break
          resp=$(timeout -t 1 /bin/bash /root/redis-cli.sh -h $R_HOST get "snapshot-snapping")
          sleep 1
          tries_left=$((tries_left-1))
          log "Waiting $tries_left more times."
        done
      fi

      >&2 /bin/bash /root/startup-waits.sh

      # start chaosnode
      log "starting chaosnode"
      chaosnode --set-ndaunode $(cat /root/.ndau/ndau-address)
      chaosnode \
        -spec http://{{ template "nodegroup.fullname" . }}-chaos-noms-service:{{ .Values.chaos.noms.port }} \
        -addr 0.0.0.0:{{ required ".Values.chaosnode.port required" .Values.chaosnode.port }} \
        -index {{ template "nodegroup.fullname" . }}-chaos-redis-service:{{ .Values.chaos.redis.port }} &
      pid=$! # get chaosnode pid
      log "chaosnode started $pid"
    }

    snapshot() {
      log "starting snapshot"
      kill $pid
      while kill -0 $pid; do log "waiting for $THIS_SERVICE to stop"; sleep 1; done;
      log "done waiting"
      >&2 /bin/bash /root/make-snapshot.sh
      startup
    }

    shutdown() {
      log "Shutting down"
      >&2 /bin/bash /root/shutdown-waits.sh
      kill $pid
      while kill -0 $pid; do log "waiting for $THIS_SERVICE to stop"; sleep 1; done;
      log "done waiting"
      exit 0
    }

    startup

    # wait for a sigterm and run shutdown
    trap shutdown SIGTERM

    # main loop
    log "starting main loop"
    while true; do
      if [ "$SNAPSHOTGUN_ENABLED" == "true" ]; then
        # snapshot if this service has been told to snapshot by redis
        sleep 2
        res=$(timeout -t 2 /bin/bash /root/redis-cli.sh -h $R_HOST get "snapshot-$THIS_SERVICE")
        [ "$res" == "1" ] && snapshot
      else
        sleep 42
      fi
    done


  startup-waits.sh: |

    log () {
      >&2 echo "$THIS_SERVICE-startup-waits: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-startup-waits: $@"
      exit 1
    }

    wait_for() {
      service=$1
      pod=$2
      port=$3

      log starting $service wait loop
      until nc -z -w 1 $pod $port; do
        log waiting for $pod on $port to accept connection
        sleep 2
      done
    }

    log "Starting wait loops"
    wait_for redis {{ template "nodegroup.fullname" . }}-chaos-redis-service {{ .Values.chaos.redis.port }}
    wait_for noms {{ template "nodegroup.fullname" . }}-chaos-noms-service {{ .Values.chaos.noms.port }}
    log "Done"

  shutdown-waits.sh: |

    log () {
      >&2 echo "$THIS_SERVICE-shutdown-waits: $@"
    }

    err () {
      >&2 echo "$THIS_SERVICE-shutdown-waits: $@"
      exit 1
    }

    # wait for waits until a service is shut down
    wait_for() {
      service=$1
      pod=$2
      port=$3

      log starting $service wait loop
      until ! nc -z -w 5 $pod $port; do
        log waiting for $pod on $port to become inactive
        sleep 2
      done
    }

    log "Starting wait loops"
    wait_for chaos-tm {{ template "nodegroup.fullname" . }}-chaos-tendermint-service {{ .Values.chaos.tendermint.ports.rpc }}
    log "Done"

{{ end }}
